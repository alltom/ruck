A port of ChucK's strong timing to Ruby!

Use Ruck's "shreds" to coordinate interleaved execution
of threads (continuations) with precise virtual timing.
Actual run-time is abstracted and shreds declare how much
virtual time they took to execute. Scheduling of shreds
is done by a ...

  SHREDULER

UGenShreduler:

  This shreduler calculates an audio unit generator graph's
  output in virtual time. The graph can be modified by
  shreds all the while.

  The graph is written in Ruby for flexibility, so it's
  too slow (on my computer) for real time, so there is no
  real-time playback. You can use WavOut, though.
  (See ex01.rb)

  Check out the library of built-in unit generators in ugen/
  and make your own.

  Unit Generator Usage
  ====================

  Play a sine wave (ex02.rb):

    s = SinOsc.new(:freq => 440)
    w = WavOut.new(:filename => "ex02.wav")
    s >> w >> blackhole
    play 3.seconds

  Attach lambdas to unit generator attributes (ex03.rb):

    wav = WavOut.new(:filename => "ex03.wav")
    sin2 = SinOsc.new(:freq => 3)
    sin = SinOsc.new(:freq => L{ sin2.last * 220 + 660 },
                     :gain => L{ 0.5 + sin2.last * 0.5 })
    [sin >> wav, sin2] >> blackhole
    play 3.seconds


RealTimeShreduler

  This shreduler attempts to keep virtual time in line with
  real time.
  (See ex10.rb)

MIDIShreduler

  This shreduler uses MIDIator and midilib to support live
  MIDI playback and saving MIDI to disk. An example runner
  is provided in midi_runner.rb which you invoke like this:
  
    $ ruby midilib_runner.rb MIDI_FILENAME NUM_TRACKS LIVE SCRIPT_FILENAME [...]
  
  where LIVE is "no" to only save the MIDI output, or "yes"
  to also play in real-time.

USAGE
=====

ugen_runner.rb is an (example) program that lets you run scripts
as you do with ChucK, with a shreduler that pulls samples from
the unit generator graph (through the blackhole):

  $ ruby ugen_runner.rb examples/ex01.rb

It uses a UGenShreduler with a hard-coded sample rate. You can use it
as an example for how to embed your own shreduler. It boils down
to this:

  require "ruck"
  
  @shreduler = Ruck::Shreduler.new # replace with your subclass
  
  # repeat this part as necessary to seed @shreduler with shreds
  @shreduler.spork("main") do
    ...
  end
  
  # this returns when no shreds remain
  @shreduler.run
