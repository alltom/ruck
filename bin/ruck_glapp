#!/usr/bin/env ruby
$:.unshift File.join(File.dirname(__FILE__), '..', 'lib')

# requires glapp gem
# sudo gem install alltom-glapp
# see http://alltom.com/pages/glapp for more details

require "ruck"

require "rubygems"
require "glapp"

class GLAppShreduler < Ruck::Shreduler
  def initialize
    @shred_queues = {}
    qs = [:frame, :key_down, :key_up, :mouse_down, :mouse_up, :mouse_move]
    qs.each { |q| @shred_queues[q] = [] }
    super
  end
  
  def actual_now
    Time.now - @start_time
  end
  
  def sleep_current_til(queue)
    shred = current_shred
    @shreds.delete(shred)
    @shred_queues[queue] << shred
    shred.yield(0)
    
    puts "#{shred} coming back from yield"
    ev = @ev
    @ev = nil
    ev
  end
  
  def raise_event(ev, queue)
    # should use actual_now, but don't want to skip over execution of other shreds
    new_now = actual_now
    new_now = [new_now, next_shred.now].min if next_shred
    
    puts "raising #{queue}"
    @shred_queues[queue].each do |shred|
      puts "setting up #{shred}"
      shred.now = new_now
      @shreds << shred
      @ev = ev
      invoke_shred shred
    end
    
    @shred_queues[queue] = []
  end
  
  def catch_up
    @start_time ||= Time.now
    
    while shreds.length > 0 && next_shred.now < actual_now
      run_one
    end
  end
end

module ShredLocal
  def spork(name = "unnamed", &shred)
    SHREDULER.spork(name, &shred)
  end
  
  def wait(seconds)
    SHREDULER.current_shred.yield(seconds)
  end
  
  def wait_for_frame
    SHREDULER.sleep_current_til(:frame)
  end
  
  def wait_for_key_down
    SHREDULER.sleep_current_til(:key_down)
  end
  
  def wait_for_key_up
    SHREDULER.sleep_current_til(:key_down)
  end
  
  def wait_for_mouse_down
    SHREDULER.sleep_current_til(:mouse_down)
  end
  
  def wait_for_mouse_up
    SHREDULER.sleep_current_til(:mouse_up)
  end
  
  def wait_for_mouse_move
    SHREDULER.sleep_current_til(:mouse_move)
  end
end

class MySketch
  include GLApp
  
  def setup
    ARGV.each do |filename|
      SHREDULER.spork(filename) do
        require filename
      end
    end
    @events = []
  end
  
  def draw
    @events.each do |pair|
      ev, queue = pair
      SHREDULER.raise_event ev, queue
    end
    @events = []
    
    SHREDULER.catch_up # execute shreds whose time came while drawing previous frame
    
    SHREDULER.raise_event Object.new, :frame
    
    SHREDULER.catch_up # execute dequeued shreds (and if this takes a while, some others)
  end
  
  def keyboard_down(key, modifiers)
    @events << [Struct.new(:key).new(key), :key_down]
  end
  
  def keyboard_up(key, modifiers)
    @events << [Struct.new(:key).new(key), :key_up]
  end
  
  def special_keyboard_down(key, modifiers)
    @events << [Struct.new(:key).new(key), :key_down]
  end
  
  def special_keyboard_up(key, modifiers)
    @events << [Struct.new(:key).new(key), :key_up]
  end
  
  def mouse_click(button, state, x, y)
    puts "mouse click #{button}, #{state}"
  end
  
  def mouse_motion(x, y)
    @events << [Struct.new(:x, :y).new(x, y), :mouse_move]
  end
end

SHREDULER = GLAppShreduler.new

include GLApp::Helpers
include ShredLocal
MySketch.new.show 800, 600, "My Sketch"
