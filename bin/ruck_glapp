#!/usr/bin/env ruby
$:.unshift File.join(File.dirname(__FILE__), '..', 'lib')

# requires glapp gem
# sudo gem install alltom-glapp
# see http://alltom.com/pages/glapp for more details

require "ruck"

require "rubygems"
require "glapp"

class GLAppShreduler < Ruck::Shreduler
  def initialize
    @shreds_waiting_for_next_frame = []
    super
  end
  
  def actual_now
    Time.now - @start_time
  end
  
  def enqueue_for_next_frame(shred)
    @shreds_waiting_for_next_frame << shred
    @shreds.delete(shred)
  end
  
  def next_frame_has_arrived
    @shreds += @shreds_waiting_for_next_frame
    
    @shreds_waiting_for_next_frame.each do |shred|
      shred.now = actual_now
    end
    
    @shreds_waiting_for_next_frame = []
  end
  
  def catch_up
    @start_time ||= Time.now
    
    while shreds.length > 0 && next_shred.now < actual_now
      run_one
    end
  end
end

module ShredLocal
  def spork(name = "unnamed", &shred)
    SHREDULER.spork(name, &shred)
  end
  
  def wait_for_frame
    SHREDULER.enqueue_for_next_frame(SHREDULER.current_shred)
    SHREDULER.current_shred.yield(0)
  end
  
  def wait(seconds)
    SHREDULER.current_shred.yield(seconds)
  end
end

class MySketch
  def setup
    ARGV.each do |filename|
      SHREDULER.spork(filename) do
        require filename
      end
    end
  end
  
  def draw
    SHREDULER.catch_up # execute shreds whose time came while drawing previous frame
    SHREDULER.next_frame_has_arrived # enqueue shreds waiting for this frame
    SHREDULER.catch_up # execute dequeued shreds (and if this takes a while, some others)
  end
end

include GLApp
include ShredLocal
SHREDULER = GLAppShreduler.new

MySketch.new.show 800, 600, "My Sketch"
